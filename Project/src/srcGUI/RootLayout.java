package srcGUI;

import errorHandler.MyException;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.geometry.Insets;
import javafx.geometry.Point2D;
import javafx.scene.control.*;
import javafx.scene.input.*;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.VBox;
import javafx.stage.FileChooser;
import javafx.util.Pair;
import srcBacked.BlockPosition;
import srcBacked.MyPort;
import srcBacked.SchemeManager;
import srcBacked.blocks.*;
import srcBacked.port.MyPortIn;
import srcBacked.port.MyPortOut;

import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

/**
 * RootLayout.java - Class responsible for controlling and setting up the GUI as a whole
 */
public class RootLayout extends AnchorPane{

	@FXML SplitPane base_pane;
	@FXML AnchorPane right_pane;
	@FXML VBox left_pane;

	private DragIcon mDragOverIcon = null;
	
	private EventHandler<DragEvent> mIconDragOverRoot = null;
	private EventHandler<DragEvent> mIconDragDropped = null;
	private EventHandler<DragEvent> mIconDragOverRightPane = null;
	private SchemeManager sm;

	private static final long serialVersionUID = 1L;

	// for connection
	private boolean portClicked; // check when connecting nodes if we clicked for the first or second time

	/**
	 * Constructor for the class
	 * @param sm Instance of the SchemeManager which controls everything
	 */
	public RootLayout(SchemeManager sm) {

		this.sm = sm;
		FXMLLoader fxmlLoader = new FXMLLoader(
				getClass().getResource("/srcGUI/resources/RootLayout.fxml")
				);
		
		fxmlLoader.setRoot(this); 
		fxmlLoader.setController(this);
		
		try { 
			fxmlLoader.load();
        
		} catch (IOException exception) {
		    throw new RuntimeException(exception);
		}
	}

	/**
	 * Return right pane
	 * @return right pane
	 */
	public AnchorPane getRight_pane() {
		return right_pane;
	}

	/**
	 * Method for creating a dialog so user can input values in the input ports
	 * @param numberOfValues number of values in a port
	 * @param keys keys, the types in port to be set
	 * @param portIcon instance of the port in the GUI
	 * @throws MyException When calling with wrong number of input values
	 */
	private void dialog(int numberOfValues, String[] keys, PortIcon portIcon) throws MyException {

		Dialog<Pair<String, String>> dialog = new Dialog<>();
		dialog.setTitle("Input port input values");

		// Set the button types.
		ButtonType loginButtonType = new ButtonType("OK", ButtonBar.ButtonData.OK_DONE);
		dialog.getDialogPane().getButtonTypes().addAll(loginButtonType, ButtonType.CANCEL);

		GridPane gridPane = new GridPane();
		gridPane.setHgap(10);
		gridPane.setVgap(10);
		gridPane.setPadding(new Insets(20, 150, 10, 10));

		TextField textfield1 = new TextField();
		TextField textfield0 = new TextField();

		switch (numberOfValues){
			case 2:
				// TODO when 2 types
				gridPane.add(new Label("Type " + keys[1]), 0, 0);
				gridPane.add(textfield1, 1, 0);
			case 1:
				gridPane.add(new Label("Type " + keys[0]), 0, 1);
				gridPane.add(textfield0, 1, 1);
				break;
			default:
				throw new MyException("Calling dialog() with wrong number of input values.");
		}

		dialog.getDialogPane().setContent(gridPane);
		Optional<Pair<String, String>> result = dialog.showAndWait();
		System.out.println(keys[0] + " " + Double.parseDouble(textfield0.getText()));

		if(result.isPresent()){
			Map<String, Double> mapPort = new HashMap<String, Double>();
			switch (numberOfValues){
				case 2:
					mapPort.put(keys[1], Double.parseDouble(textfield1.getText()));
				case 1:
					mapPort.put(keys[0], Double.parseDouble(textfield0.getText()));
					break;
			}
			try {
				sm.getPortByFXObject(portIcon).setData(mapPort);
			} catch (MyException e) {
				e.printStackTrace();
			}
		}
	}

	/**
	 * Shows alert in GUI when ports are empty when trying to calculate
	 */
	public void emptyPortAlert(){
		Alert alert = new Alert(Alert.AlertType.WARNING);
		alert.setTitle("Warning");
		alert.setHeaderText("Some input port is empty!");
		alert.setContentText("Please, check the input ports an enter all the values.");
		alert.showAndWait();
	}

	/**
	 * Shows alert in GUI when the input file is wrong
	 */
	public void wrongInputFile(){
		Alert alert = new Alert(Alert.AlertType.WARNING);
		alert.setTitle("Warning");
		alert.setHeaderText("Wrong input file");
		alert.setContentText("Please, choose a file which was generated by this application.");
		alert.showAndWait();
	}

	/**
	 * Shows info about the program in alert window
	 */
	public void aboutAlert(){
	    Alert alert = new Alert(Alert.AlertType.INFORMATION);
	    alert.setTitle("About");
	    alert.setHeaderText("Information about this program");
	    alert.setContentText("Authors: Maro≈° Orsak and Tom Kunickij");
        alert.showAndWait();
    }

	/**
	 * Shows info about the block when hover by the mouse
	 * @param dragIcon the GUI block
	 */
	private void addTooltip(DragIcon dragIcon){
		dragIcon.addEventFilter(MouseEvent.MOUSE_ENTERED, new EventHandler<MouseEvent>() {
			@Override
			public void handle(MouseEvent mouseEvent) {
				System.out.println("mouse detected! " + mouseEvent.getSource());
				Tooltip tooltip = new Tooltip();

				try {
					tooltip.setText(sm.getBlockByFXObject(dragIcon).getData());
				} catch (Exception e) {
					e.printStackTrace();
				}
				Tooltip.install(dragIcon,tooltip);
			}
		});
	}

	/**
	 * Init the whole application, set everything whot is needed before doing any operations
	 */
	@FXML
	private void initialize() {

		String buttonStyle = "-fx-background-color: \n" +
				"        #090a0c,\n" +
				"        linear-gradient(#38424b 0%, #1f2429 20%, #191d22 100%),\n" +
				"        linear-gradient(#20262b, #191d22),\n" +
				"        radial-gradient(center 50% 0%, radius 100%, rgba(114,131,148,0.9), rgba(255,255,255,0));\n" +
				"    -fx-background-radius: 5,4,3,5;\n" +
				"    -fx-background-insets: 0,1,2,0;\n" +
				"    -fx-text-fill: white;\n" +
				"    -fx-effect: dropshadow( three-pass-box , rgba(0,0,0,0.6) , 5, 0.0 , 0 , 1 );\n" +
				"    -fx-font-family: \"Arial\";\n" +
				"    -fx-font-size: 12px;\n" +
				"    -fx-padding: 10 20 10 20;" +
				"    -fx-border-radius: 10px;";

		// SAVE BUTTON **************************************
		Button buttonSave = new Button("Save Scheme");
		buttonSave.setStyle(buttonStyle);
		buttonSave.setMinSize(170,50);
		buttonSave.setLayoutX(0);
		getChildren().add(buttonSave);

		buttonSave.setOnAction(new EventHandler<ActionEvent>() {
			@Override public void handle(ActionEvent e) {

				System.out.println("Saving begins");
				FileChooser fileChooser = new FileChooser();
				fileChooser.setTitle("Save scheme");
				FileChooser.ExtensionFilter extFilter = new FileChooser.ExtensionFilter("Binary files (*.bin)", "*.bin");
				fileChooser.getExtensionFilters().add(extFilter);
				File file = fileChooser.showSaveDialog(null);
				if (file != null) {
					try {
						sm.saveScheme(file);
					} catch (IOException ex) {
						ex.printStackTrace();
					} catch (MyException e1) {
						e1.printStackTrace();
					}
				}

				System.out.println("Scheme saved");
			}
		});

		// LOAD BUTTON **************************************
		Button buttonLoad = new Button("Load scheme");
		buttonLoad.setStyle(buttonStyle);
		buttonLoad.setMinSize(170,50);
		buttonLoad.setLayoutX(170);
		getChildren().add(buttonLoad);

		buttonLoad.setOnAction(new EventHandler<ActionEvent>() {
			@Override public void handle(ActionEvent e) {

				System.out.println("Load called");
				try {
					System.out.println("Clearing old schema");
					sm.clearScheme();
					System.out.println("Loading new one");

					FileChooser fileChooser = new FileChooser();
					fileChooser.setTitle("Choose your save scheme to load.");
					FileChooser.ExtensionFilter extFilter = new FileChooser.ExtensionFilter("Binary files (*.bin)", "*.bin");
					fileChooser.getExtensionFilters().add(extFilter);
					File file = fileChooser.showOpenDialog(null);
					sm.loadScheme(file);

					System.out.println("Clearing all GUI-Backend links");
					sm.getScheme().clearlinkedFxBackendPort();
					sm.getScheme().clearlinkedFxBackendBlock();
					System.out.println("Load DONE");
				} catch (Exception e1) {
					wrongInputFile();
				}

				System.out.println("Drawing blocks");
				for(BlockPosition blockPosition : sm.getScheme().getArrayOfBlocks()){
					double posX = blockPosition.getPosX();
					double posY = blockPosition.getPosY();

					DragIcon dragIcon = new DragIcon();

					if(blockPosition.getBlock() instanceof BlockAdd_2_1){
						dragIcon.setType(DragIconType.BlockAdd_2_1);
					} else if(blockPosition.getBlock() instanceof BlockSub_2_1){
						dragIcon.setType(DragIconType.BlockSub_2_1);
					} else if(blockPosition.getBlock() instanceof BlockAdd_1_1){
						dragIcon.setType(DragIconType.BlockAdd_1_1);
					} else if(blockPosition.getBlock() instanceof BlockSub_1_1){
						dragIcon.setType(DragIconType.BlockSub_1_1);
					} else if(blockPosition.getBlock() instanceof BlockMul_1_1){
						dragIcon.setType(DragIconType.BlockMul_1_1);
					} else if(blockPosition.getBlock() instanceof BlockDiv_2_1){
						dragIcon.setType(DragIconType.BlockDiv_2_1);
					} else if(blockPosition.getBlock() instanceof BlockMod_2_2){
						dragIcon.setType(DragIconType.BlockMod_2_2);
					} else if(blockPosition.getBlock() instanceof BlockConvertT1toT2){
						dragIcon.setType(DragIconType.BlockConvertT1toT2);
					} else if(blockPosition.getBlock() instanceof BlockConvertT2toT1){
						dragIcon.setType(DragIconType.BlockConvertT2toT1);
					} else {
						System.out.println("Missing if statement in load action, when setting setType()");
					}

					// when click on the block in frontend
					addTooltip(dragIcon);

					right_pane.getChildren().add(dragIcon);

					dragIcon.relocateToPoint(
							new Point2D(posX, posY)
					);

					sm.getScheme().getLinkedFxBackendBlock().put(dragIcon, blockPosition.getBlock());

					createGUIclickablePorts(blockPosition.getBlock().getPortsIn(), posX + 50, posY + 50);
					createGUIclickablePorts(blockPosition.getBlock().getPortsOut(), posX + 50, posY + 50);
				}

				sm.getLiner().drawAllLinks();

			}
		});

		// DELETE SCHEME BUTTON **************************************
		Button btnClearScheme = new Button("Clear Scheme");
		btnClearScheme.setStyle(buttonStyle);
		btnClearScheme.setMinSize(170,50);
		btnClearScheme.setLayoutX(340);
		getChildren().add(btnClearScheme);

		btnClearScheme.setOnAction(new EventHandler<ActionEvent>() {
			@Override public void handle(ActionEvent e) {
				System.out.println("Clearing scheme!");
				sm.clearScheme();
			}
		});

		// CLEAR ALL VALUES **************************************
		Button btnClearValues = new Button("Clear values");
		btnClearValues.setStyle(buttonStyle);
		btnClearValues.setMinSize(170,50);
		btnClearValues.setLayoutX(510);
		getChildren().add(btnClearValues);

		btnClearValues.setOnAction(new EventHandler<ActionEvent>() {
			@Override public void handle(ActionEvent e) {
				System.out.println("Calculations and ports cleared");
				sm.clearCalculations();
			}
		});

		// CALCULATE SCHEME **************************************
		Button btnCalculateScheme = new Button("Calculate scheme");
		btnCalculateScheme.setStyle(buttonStyle);
		btnCalculateScheme.setMinSize(170,50);
		btnCalculateScheme.setLayoutX(680);
		getChildren().add(btnCalculateScheme);

		btnCalculateScheme.setOnAction(new EventHandler<ActionEvent>() {
			@Override public void handle(ActionEvent e) {
				System.out.println("Hell yeah!");
				try {
					// IMPORTANT to set
					sm.setCalculateOnlyOneStep(false);
					sm.calculate();
				} catch (InterruptedException e1) {
					e1.printStackTrace();
				}
			}
		});

        // CALCULATE STEP **************************************
        Button btnCalculateStep = new Button("Calculate step");
        btnCalculateStep.setStyle(buttonStyle);
        btnCalculateStep.setMinSize(170,50);
        btnCalculateStep.setLayoutX(850);
        getChildren().add(btnCalculateStep);

        btnCalculateStep.setOnAction(new EventHandler<ActionEvent>() {
            @Override public void handle(ActionEvent e) {
                System.out.println("Hell yeah!");
                try {
                    // IMPORTANT to set
                    sm.setCalculateOnlyOneStep(true);
                    sm.calculate();
                } catch (InterruptedException e1) {
                    e1.printStackTrace();
                }
            }
        });

        // ABOUT ***********************************************
        Button btnAbout = new Button("About");
        btnAbout.setStyle(buttonStyle);
        btnAbout.setMinSize(170,50);
        btnAbout.setLayoutX(1020);
        getChildren().add(btnAbout);

        btnAbout.setOnAction(new EventHandler<ActionEvent>() {
            @Override public void handle(ActionEvent e) {
                System.out.println("Hell yeah!");
                aboutAlert();
            }
        });

		mDragOverIcon = new DragIcon();
		mDragOverIcon.setVisible(false);
		mDragOverIcon.setOpacity(0.65);
		getChildren().add(mDragOverIcon);

		//populate left pane with multiple colored icons for testing
		for (int i = 0; i < 9; i++) {
			
			DragIcon icn = new DragIcon();
			
			addDragDetection(icn);
			
			icn.setType(DragIconType.values()[i]);
			left_pane.getChildren().add(icn);
		}
		
		buildDragHandlers();
	}

	/**
	 * Adds drag detection
	 * @param dragIcon the icon
	 */
	private void addDragDetection(DragIcon dragIcon) {
		
		dragIcon.setOnDragDetected (new EventHandler <MouseEvent> () {

			@Override
			public void handle(MouseEvent event) {

				// set drag event handlers on their respective objects
				base_pane.setOnDragOver(mIconDragOverRoot);
				right_pane.setOnDragOver(mIconDragOverRightPane);
				right_pane.setOnDragDropped(mIconDragDropped);

				
				// get a reference to the clicked DragIcon object
				DragIcon icn = (DragIcon) event.getSource();
				
				//begin drag ops
				mDragOverIcon.setType(icn.getType());
				mDragOverIcon.relocateToPoint(new Point2D (event.getSceneX(), event.getSceneY()));
            
				ClipboardContent content = new ClipboardContent();
				DragContainer container = new DragContainer();
				
				container.addData ("type", mDragOverIcon.getType().toString());
				content.put(DragContainer.AddNode, container);

				mDragOverIcon.startDragAndDrop (TransferMode.ANY).setContent(content);
				mDragOverIcon.setVisible(true);
				mDragOverIcon.setMouseTransparent(true);
				event.consume();					
			}
		});
	}

	/**
	 * sets on click listener to FX port icon
	 * @param portIcon the icon
	 */
	private void setOnClickListenerToPort(PortIcon portIcon){
		// when click on the ports
		portIcon.addEventFilter(MouseEvent.MOUSE_PRESSED, new EventHandler<MouseEvent>() {
			@Override
			public void handle(MouseEvent mouseEvent) {

				if (mouseEvent.getButton() == MouseButton.SECONDARY) {
					System.out.println("Right button clicked");
					if(sm.getPortByFXObject(portIcon) instanceof MyPortOut){
						return;
					}
					try {
						MyPort port = sm.getPortByFXObject(portIcon);
						if(!(port.getLinker().isThisInputPortConnected((MyPortIn) port))){
							dialog(port.howManyValues(), port.getKeys(), portIcon);
						} else {
							System.out.println("Cannot set connected port.");
						}
					} catch (MyException e) {
						e.printStackTrace();
					}
				} else {
					sm.getPortByFXObject(portIcon).printPortData();
					// connect the ports in backend
					try {

						System.out.println("LayoutXY " + portIcon.getLayoutX() + " " + portIcon.getLayoutY());
						sm.getLiner().click(portIcon);

					} catch (MyException e) {
						e.printStackTrace();
					}
				}
			}
		});
	}

	/**
	 * Method which creating GUI clickable ports and sets concrete coordinates in the scheme layout 
	 * @param ports the ports we want ot create clickable
	 * @param curX where to create the port, X value
	 * @param curY where to create the port, Y value
	 */
	private void createGUIclickablePorts(MyPort[] ports, double curX, double curY){
		int numberOfInputPorts = ports.length;
		int posY = (numberOfInputPorts == 1) ? 10 : 30; // good only for 2 ports, no more
		int posX; // goes right or left if portIn/portOut
		for (MyPort myPort : ports){
			PortIcon portIcon = new PortIcon();
			setOnClickListenerToPort(portIcon);
			right_pane.getChildren().add(portIcon);
			if(myPort instanceof MyPortIn){
				posX = -70;
			} else {
				posX = 50;
			}
			Point2D coordinates = new Point2D((curX + posX), (curY - posY));
			sm.linkedFXPortsToBackend(portIcon, myPort);
			portIcon.relocateToPoint(coordinates);
			posY -= 40;
		}
	}

	/**
	 * Builds drag handlers
	 */
	private void buildDragHandlers() {
		
		// drag over transition to move widget form left pane to right pane
		mIconDragOverRoot = new EventHandler <DragEvent>() {

			@Override
			public void handle(DragEvent event) {
				
				Point2D p = right_pane.sceneToLocal(event.getSceneX(), event.getSceneY());

				//turn on transfer mode and track in the right-pane's context 
				//if (and only if) the mouse cursor falls within the right pane's bounds.
				if (!right_pane.boundsInLocalProperty().get().contains(p)) {
					
					event.acceptTransferModes(TransferMode.ANY);
					mDragOverIcon.relocateToPoint(new Point2D(event.getSceneX(), event.getSceneY()));
					return;
				}

				event.consume();
			}
		};


		mIconDragOverRightPane = new EventHandler <DragEvent> () {

			@Override
			public void handle(DragEvent event) {

				event.acceptTransferModes(TransferMode.ANY);

				mDragOverIcon.relocateToPoint(
								new Point2D(event.getSceneX(), event.getSceneY())
				);
				event.consume();
			}
		};
				
		mIconDragDropped = new EventHandler <DragEvent> () {

			@Override
			public void handle(DragEvent event) {
				
				DragContainer container = 
						(DragContainer) event.getDragboard().getContent(DragContainer.AddNode);
				
				container.addData("scene_coords",
						new Point2D(event.getSceneX(), event.getSceneY()));
				
				ClipboardContent content = new ClipboardContent();
				content.put(DragContainer.AddNode, container);

				event.getDragboard().setContent(content);
				event.setDropCompleted(true);
			}
		};


		this.setOnDragDone (new EventHandler <DragEvent> () {
			@Override
			public void handle(DragEvent event) {

				right_pane.removeEventHandler(DragEvent.DRAG_OVER, mIconDragOverRightPane);
				right_pane.removeEventHandler(DragEvent.DRAG_DROPPED, mIconDragDropped);
				base_pane.removeEventHandler(DragEvent.DRAG_OVER, mIconDragOverRoot);

				mDragOverIcon.setVisible(false);

				DragContainer container =
						(DragContainer) event.getDragboard().getContent(DragContainer.AddNode);

				if (container != null) {
					if (container.getValue("scene_coords") != null) {

						DragIcon droppedIcon = new DragIcon();
						Point2D cursorPoint = container.getValue("scene_coords");
						double curX = cursorPoint.getX();
						double curY = cursorPoint.getY();

						System.out.println("DROPPED X:" + (curX) + " Y:" + (curY));
						// create Block in backend
						try {
							DragIconType type = DragIconType.valueOf(container.getValue("type"));
							MyPort[][] ports;
							switch (type){
								case BlockAdd_2_1:
									ports = sm.createBlockAdd_2_1((int) (curX - 50), (int) (curY - 50), droppedIcon);
									break;
								case BlockSub_2_1:
									ports = sm.createBlockSub_2_1((int) (curX - 50), (int) (curY - 50), droppedIcon);
									break;
								case BlockAdd_1_1:
									ports = sm.createBlockAdd_1_1((int) (curX - 50), (int) (curY - 50), droppedIcon);
									break;
								case BlockSub_1_1:
									ports = sm.createBlockSub_1_1((int) (curX - 50), (int) (curY - 50), droppedIcon);
									break;
								case BlockMul_1_1:
									ports = sm.createBlockMul_1_1((int) (curX - 50), (int) (curY - 50), droppedIcon);
									break;
								case BlockDiv_2_1:
									ports = sm.createBlockDiv_2_1((int) (curX - 50), (int) (curY - 50), droppedIcon);
									break;
								case BlockMod_2_2:
									ports = sm.createBlockMod_2_2((int) (curX - 50), (int) (curY - 50), droppedIcon);
									break;
								case BlockConvertT1toT2:
									ports = sm.BlockConvertT1toT2((int) (curX - 50), (int) (curY - 50), droppedIcon);
									break;
								case BlockConvertT2toT1:
									ports = sm.BlockConvertT2toT1((int) (curX - 50), (int) (curY - 50), droppedIcon);
									break;
								default:
									throw new MyException("This type ob clock does not exist. Programmer went wrong, haha...");
							}

							// IN PORTS
							createGUIclickablePorts(ports[0], curX, curY);
							createGUIclickablePorts(ports[1], curX, curY);
						} catch (MyException e) {
							e.printStackTrace();
						}

						// when click on the block in frontend
						droppedIcon.addEventFilter(MouseEvent.MOUSE_PRESSED, new EventHandler<MouseEvent>() {
							@Override
							public void handle(MouseEvent mouseEvent) {

								System.out.println("mouse click detected! " + mouseEvent.getSource());
								sm.getBlockByFXObject(droppedIcon).printData();
							}
						});

						// when click on the block in frontend
						addTooltip(droppedIcon);

//						System.out.println("DragIconType" + DragIconType.valueOf(container.getValue("type")));
						droppedIcon.setType(DragIconType.valueOf(container.getValue("type")));
						right_pane.getChildren().add(droppedIcon);

						droppedIcon.relocateToPoint(
								new Point2D(curX - 50, curY - 50)
						);
					}
					event.consume();
				}
			}
		});
	}
}
